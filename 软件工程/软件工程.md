# 软件工程

## 第⼀章：软件⼯程概述

### 1.1 软件危机与软件⼯程

#### 软件的特征

| 序号 | 特征                                                             |
| ---- | ---------------------------------------------------------------- |
| 1    | 软件是逻辑层⾯上的，不是有形的物理⽂件，与硬件具有完全不同的特征 |
| 2    | 软件在使⽤过程中不会磨损，但会退化                               |
| 3    | 软件开发早起是⼀⻔艺术，但⽬前越来越趋于标准化                   |
| 4    | 软件同时也是⼀种逻辑实体，具有抽象性                             |
| 5    | 软件会变得越来越复杂                                             |

#### 软件的组成

| 组成 | 描述                                         |
| ---- | -------------------------------------------- |
| 程序 | 能够运⾏的、能提供所希望的功能和性能的指令集 |
| 数据 | ⽀持程序运⾏的数据                           |
| 文档 | 描述程序研制的过程、⽅法及使⽤的记录         |

#### 解决软件危机的方法

| 序号 | 方法                                                         |
| ---- | ------------------------------------------------------------ |
| 1    | 要对软件有正确的认识                                         |
| 2    | 推⼴使⽤软件开发成功的技术和⽅法，研究探索更有效的技术和⽅法 |
| 3    | 开发和使⽤更好的软件⼯具                                     |
| 4    | 对于时间、⼈员、资源等，需要引⼊更加合理的管理措施           |

#### 软件⼯程定义
将系统化、规范化、可量化的⼯程原则和⽅法应⽤于软件的开发、运⾏、维护及对其中⽅法的理论研究。其主要⽬
标是⾼效开发⾼质量的软件，降低开发成本。
#### 软件⼯程知识体系

| 开发过程 | 支持过程           |
| -------- | ------------------ |
| 软件需求 | 软件配置管理       |
| 软件设计 | 软件工程管理       |
| 软件构造 | 软件⼯程过程       |
| 软件测试 | 软件⼯程⼯具与⽅法 |
| 软件维护 | 软件量度           |

#### 软件工程基本原理

| 序号 | 方法                             |
| ---- | -------------------------------- |
| 1    | ⽤分阶段的⽣命周期计划严格管理   |
| 2    | 坚持进⾏阶段评审                 |
| 3    | 实⾏严格的产品控制               |
| 4    | 采⽤现代程序设计技术             |
| 5    | 结果应能清楚地审查               |
| 6    | 开发⼩组的⼈员应该少⽽精         |
| 7    | 承认不断改进软件⼯程实践的必要性 |

### 1.2 系统⼯程与UML

#### 系统工程定义
为了更好的达到系统⽬标，对系统的构成要素、组织结构、信息流动和控制机构等进⾏分析与设计的技术。
#### 系统工程性质

1. 系统⼯程⽤定量和定性相结合的系统思想和⽅法处理⼤型复杂系统的问题。
2. 系统分析的常⽤⽅法是层次分析⽅法，它将问题分解为不同的组成因素，并按照因素间的相互关联影响及⾪属
   关系将因素按不同层次聚集组合，形成⼀个多层次的分析结构模型。

#### 产品工程的层次结构模型

| 层次   | 表示                                   | 描述                                       |
| ------ | -------------------------------------- | ------------------------------------------ |
| 最高层 | 领域目标                               | 层次分析到达的总⽬标                       |
| 中间层 | 中间环节                               | 采取某⼀⽅案来实现预订总⽬标涉及的中间环节 |
| 最底层 | 要选⽤的解决问题的各种措施、策略、⽅案 |                                            |

模型优点：更好的体现出⼈们对系统的理解和驾驭能⼒

#### 系统⼯程建模特点

系统⼯程本质上是层次化的。对应系统⼯程的不同层次，相应的模型会被创建和使⽤，如需求模型中的模型要能体
现出对系统宏观上的理解，下层模型要能明确具体⼦系统的需求。

#### 统⼀建模语⾔UML

1. UML (Unified Model Language)是继20世纪80年代末，90年代初⾯向对象分析与设计⽅法（OOA&D）⽽出
   现的。
2. UML统⼀了Booch、OMT、OOSE⽅法，并在此基础上进⾏了标准化，如今已经成为对象管理组织（OMG）
   的标准之⼀。
3. UML是⼀种语⾔或⼯具，不是⼀种⽅法。它致⼒于分析设计的描述，其表述形式以图形⽅式为主，其描述形
   式本质上仍归为⾮正式的⽅式。

#### UML的产⽣——“三朋友”

| 姓名            | 贡献                                                                                     |
| --------------- | ---------------------------------------------------------------------------------------- |
| Grady Booch     | ⾯向对象⽅法最早倡导者之⼀，提出Booch⽅法                                                |
| James Rumbaugh | 使⽤对象建模技术（OMT），适⽤于以数据为中⼼的信息系统                                    |
| Ivar Jacobson   | 提出⽤例（Use Case），进⽽提出OOSE⽅法，以⽤例为中⼼，进⾏系统需求的获取、分析及高层设计 |

#### ⽅法的战争
由于采⽤不同的符号进⾏类与对象的表示及关联，相似符号在不同模型中表示的意义不尽相同。
#### UML功能
UML将语⾔表示与过程进⾏分离。

| 功能     | 说明                                                                                         |
| -------- | -------------------------------------------------------------------------------------------- |
| 可视化   | 帮助开发者理解和解决问题，方便沟通交流，发现设计草图中                                       |
| 规格说明 | 通过一种通用的、精确地、没有歧义的通信机制进行                                               |
| 构造     | 使用软件工具对模型进行解释和说明，将模型映射到某种计算机语言上来实现，加快系统建模和实现速度 |
| 文档化   | 使用UML同时生成系统设计文档                                                                  |

#### UML特性

1. 提供给⽤户⾼层建模⽅法，针对⽤户需求的⾼层抽象，具体表现为描述组建的构成及联系；这与⾃然语⾔描述
   不同的是，⾃然语⾔具有歧义和含糊不清的缺点。
2. UML的定义是通过元模型描述的。

#### UML 2.0使⽤模型

| 模型       | 说明                                                                 |
| ---------- | -------------------------------------------------------------------- |
| 用例图     | 表示系统与使用者之间的交互，有助于将需求映射到系统                   |
| 活动图     | 表示系统中顺序和并行的活动                                           |
| 类图       | 表示类、接口及其之间的关系                                           |
| 对象图     | 表示类图中定义的类的对象实例，配置是对系统的模拟                     |
| 顺序图     | 表示对象之间的互动顺序                                               |
| 通信图     | 表示对象交互的方法和需要支持交互的连接                               |
| 时序图     | 表示重点对象之间的交互时间安排                                       |
| 交互概况图 | 表示将顺序图、时序图、通信图收集到一起以捕捉系统中发生的重要交互情况 |
| 组成结构图 | 表示类或组件的内部，描述类间的关系                                   |
| 组件图     | 表示系统内的重要组件和彼此间交互所用的接口                           |
| 包图       | 表示类与组件集合的分级组织                                           |
| 状态图     | 表示整个生命周期中对象的状态和可以改变状态的事件                     |
| 部署图     | 表示系统最终怎样被部署到真实的世界中                                 |

### 1.3 系统开发的解空间

#### 系统开发的解空间的组成
现代的⾯向对象分析和设计⽅法是基于模型的，综合使⽤⽤例建模、静态建模、动态建模和架构建模来描述软件需
求、分析和设计模型，构成了系统开发的解空间。

| 模型     | 说明                                                                               |
| -------- | ---------------------------------------------------------------------------------- |
| 用例建模 | 系统的功能型需求按照用例和参与者进行定义                                           |
| 静态建模 | 提供了系统的结构化视图                                                             |
| 动态建模 | 提供了系统的行为视图，对象交互用于表示对象之间的通信和协作                         |
| 架构建模 | 系统的核心，使用包、子系统和构建结构来描述系统的框架结构及框架中各个部分的连接关系 |

#### 基于UML的软件建模和架构设计⽅法

1. ⽤例作为整个分析设计的驱动
2. 基于软件架构的理论和⽅法构造出软件的总体架构
3. 使⽤⾯向对象的静态和动态建模⽅法，完成以类为单元封装体和以构建为符合封装体的分析设计
4. ⽣成代码，实现系统

#### 整个过程是⼀种基于⽤例的⾼度迭代的软件开发过程

| 过程     | 说明                                             |
| -------- | ------------------------------------------------ |
| 用例建模 | 每个用例要开发一个叙述性描述的用例规约           |
| 分析设计 | 迭代式地进行系统的静态建模和动态建模             |
| 架构建模 | 设计系统的软件体系结构                           |
| 实现     | 将软件架构模型映射到可部署运行实现的模型解空间中 |

### 1.4 软件⼯程开发⽅法

#### 技术及规范

| 内容 | 说明                                                                           |
| ---- | ------------------------------------------------------------------------------ |
| 方法 | 完成软件开发各项任务的技术                                                     |
| 工具 | 为方法的运用提供自动或半自动的软件支持环境，回答“用什么做”的问题             |
| 过程 | 获得一系列任务的框架，规定完成各项任务的步骤，回答“如何控制、协调、保证质量” |

#### 传统方法

| 内容 | 说明                                                                                             |
| ---- | ------------------------------------------------------------------------------------------------ |
| 描述 | 静态的思想，将软件开发过程划分为若干个阶段，规定各个阶段必须完成的任务，各阶段间具有某种顺序性。 |
| 思维 | 分治思想                                                                                         |
| 缺点 | 缺少灵活性，不适用于软件规模比较大尤其是开发的早期需求比较模糊或经常变化。                       |

#### 面向对象方法

| 内容     | 说明                                                                         |
| -------- | ---------------------------------------------------------------------------- |
| 描述     | 动态的思想，尽可能模拟人类思维方式；对象中同时封装了实体的静态属性和动态方法 |
| 特点     | 概念层与逻辑层相互协调，强调各种逻辑关系在结构上的稳定性                     |
| 开发过程 | 主动多次迭代                                                                 |
| 思维     | 由一般到特殊，由特殊到一般，对象独立可重用                                   |

#### 面向对象方法层次关系

| 层次       | 说明                         |
| ---------- | ---------------------------- |
| 类与对象   | 类是对象的抽象               |
| 类与类     | 可以构成“继承”的层级关系   |
| 对象与对象 | 消息机制确保对信息的“封装” |

#### 对传统和面向对象方法的理解

1. 传统⽅法⼜被称为”⾯向数据流“的⽅法；传统⽅法的分析图被称为”数据流图“
2. ⾯向对象对实体进⾏抽象，简化了分析的难度并增加了可理解性，同时保证了分析模型结构的稳定性，提⾼了
   应对变化的能⼒
3. 类的封装可以直接把修改限定在⼀个特定的范围内
4. “隔离变化、应对变化、以不变应万变”正是⾯向对象优势的体现

## 第二章：软件开发过程

软件开发过程，又称软件开生命周期，是软件产品开发的任务框架和规范。

### 2.1 软件生命周期模型与软件过程

#### 4种生命周期模型

1. 顺序式  
2. 迭代式  
3. 增量式  
4. 敏捷式  

#### 3个主要时期

1. 软件定义  
2. 软件开发  
3. 软件维护  

#### 6个阶段

| 阶段 | 说明 |
|------|------|
| 可行性分析与安全计划 | 用最小的代价在尽可能短的时间内确定该软件项目是否能够开发，是否值得开发，最后给决策者提供做与不做的依据 |
| 需求分析 | 对目标软件未来需要完成的功能进行的详细分析，输出一份“需求规格说明书” |
| 软件设计 | 寻求系统求解的框架，如系统的架构设计、数据设计 |
| 编码 | 将软件设计的结果翻译成某种计算机语言可实现的程序代码 |
| 软件测试 | 分为单元测试、集成测试及系统测试三个阶段，软件测试方法又分为黑盒和白盒 |
| 软件维护 | 为软件能持续适应用户的要求延续软件使用寿命的活动 |

#### 传统生命周期模型和敏捷生命周期模型

| 传统生命周期模型 | 敏捷生命周期模型 |
|------------------|------------------|
| 顺序式瀑布模型 | 极限编程 |
| 快速原型模型 | Scrum |
| 增量式增量模型 |  |
| 迭代式螺旋模型和喷泉模型 |  |

### 2.2 传统生命周期模型

#### 瀑布模型

一种计划驱动的模型，比较适合规模较大的系统开发或者分布式的开发模式。

| 特点 | 问题 |
|------|------|
| 文档驱动，静态开发 | 模型的能力天生具有缺陷，尤其是需求模糊或不准确的系统 |
| 推迟实现 | 被动的数火式的应对问题，不希望有变化 |
| 质量保证 | 模型缺少灵活性，变更不容易 |

#### 快速原型模型

一种适合于全新系统开发，可以借助原型使用户了解到开发的方向是否正确的开发模式，适合于工期比较紧张的项目。

| 特点 | 问题 |
|------|------|
| 快速构造软件模型 | 所运用的开发技术和工具不一定是实际项目所需要的 |
| 可以尝试运用未来系统中需要的技术 | 快速建立的模型质量不能保证 |

#### 增量模型

又称演化模型，软件被视为一系列的增量构建来设计、实现、集成、测试。第一个增量往往只实现基本需求的核心产品。

| 特点 | 问题 |
|------|------|
| 各阶段交付满足客户需求的可运行产品子集 | 软件需要具备开放式的体系结构 |
| 较好适应变化 | 容易退化为“边做边改”模型使软件过程控制失去整体性 |

#### 螺旋模型

一种将瀑布模型和快速原型模型结合起来，强调了其他模型忽视的风险分析，特别适合大型复杂的系统开发的开发模式。

| 活动 | 描述 |
|------|------|
| 制定计划 | 确定软件目标，选择实施方案，设定约束条件 |
| 风险分析 | 评估所选方案，识别并排除风险 |
| 实施工程 | 开发、验证下一级产品 |
| 客户评估 | 评估开发工作计划下一阶段 |

| 问题 | 描述 |
|------|------|
| 风险分析 | 要求客户接收和详细风险分析并做出反应是不易的，这种模型往往适用于内部的大规模软件开发 |
| 利润受损 | 风险分析如果大大影响项目的利润，则风险分析毫无意义 |
| 寻找风险 | 开发者应该擅长寻找可能的风险，准确的分析风险，否则将会带来更大的风险 |

#### 喷泉模型

又称为“面向对象的生命周期模型”，生存期的各个阶段可以相互重叠和多次反复，而且在项目的整个生存期中还可以嵌入于生存期。

| 特点 | 描述 |
|------|------|
| 符合习惯思维和表达方式 | 直接针对问题域中存在的各项事物设立模型中的对象 |
| 不存在传统方法与设计之间的鸿沟，能够做到衔接紧密 | 从分析到设计不存在转换，只有局部的补充和优化，并增加与实现有关的独立部分 |
| 面向对象继承和测试也保持了连续性 | 面向对象开发阶段间的无缝特性和表示方法的一致性，是喷泉模型优于传统软件工程方法的重要因素 |

### 2.3 敏捷生命周期模型

敏捷生命周期模型适合集中式的开发模式。

#### 原则

1. 个体和互动胜过流程和工具  
2. 工作的软件胜过详尽的文档  
3. 客户合作胜过合同谈判  
4. 响应变化胜过遵循计划  

#### 两个基本特点

1. 增量交付  
2. 迭代开发  

#### 开发建议

先实现必要的用户案例，体现出软件的价值，然后在后续版本中对功能进行细化。

#### 用例定义

用户通过系统完成的有价值的目标。在敏捷生命周期模型中，用例通常作为迭代的单位，这样每次交付的都是可以部署到用户应用环境中被用户使用的、能给用户带来即时效益和价值的产品。

#### 迭代的思想

当我们对用户需求没有信心时，可以先构建后修改，通过多次反复，找到客户真正需要的软件。

#### 敏捷生命周期模型优势

| 特点 | 描述 |
|------|------|
| 精确 | 产品由开发团队和用户反馈共同推动 |
| 质量 | 对每一次迭代周期的质量都有严格要求 |
| 速度 | 提倡避免较大的前期规划，新的功能或需求变化尽可能频繁的整合到产品中 |
| 丰厚的投资回报率 | 最具价值的功能优先开发 |
| 高效的自我管理团队 | 拥有一个积极的、自我管理的、具备自由交流风格的开发团队 |

#### 极限编程

主要目的是降低需求变化的成本，引入一系列优秀的软件开发方法作为开发实践的指导，并将它们发挥到极致。

| 原则 | 描述 |
|------|------|
| 互动交流 | 团队成员之间通过日常沟通、简单设计、测试、系统隐喻及代码本身来沟通产品需求和系统设计 |
| 反馈 | 客户的实际使用、功能测试、单元测试等，都能为开发团队提供反馈信息 |
| 简单 | XP总是从一个简单地系统入手，并且只创建今天需要的功能模块 |
| 勇气 | 鼓励一些应对较高风险的良好做法 |
| 团队 | 激励团队，把相互尊重和实际的开发习惯结合 |

#### Scrum

更注重软件开发的系统化过程，它由一个开发过程、集中角色及一套规范的实施方法组成。

#### 冲刺周期

| 会议类型 | 说明 |
|----------|------|
| 计划会议 | 最重要或者最具价值的产品需求被优先安排到下一个冲刺周期 |
| 每日会议 | 每个团队成员汇报各自的进展情况，同时提出目前遇到的各种障碍 |
| 评审会议 | 开发团队将会向客户或最终用户展示新的系统功能，用户会提出意见和一些需求变化 |
| 回顾会议 | 总结上次冲刺周期中有哪些不足需要改进，有哪些值得肯定的方面 |

#### 角色

| 角色 | 说明 |
|------|------|
| 产品拥有者 | 负责产品的远景规划，平衡所有利益相关者，确定不同的产品需求的优先级 |
| 涉众 | 该角色与产品之间有直接或间接的利益关系，通常是客户或最终用户代表 |
| 专家 | 指导开发团队进行Scrum开发与实践 |
| 团队成员 | 项目开发者 |

#### DevOps（Development and Operations）

DevOps实际上是一组过程、方法与系统的统称。

#### 职责

- 他们是开发团队和客户或最终用户之间的联络点  
- 他们负责收集、编写产品需求，审查项目成果  
- 开发团队与产品拥有者之间交流的联络点  

#### 目标

1. 促进开发、技术运营和质量保证部门之间的沟通、协作与整合  
2. 自动化和可持续交付  

## 第三章 需求分析

### 3.1 需求分析活动

需求分析阶段一般通过一份需求规格说明书的文档描述项目应该实现的内容。

#### 可行性分析

明确系统的功能性需求、边界位置，以及在技术、经济、法律或操作等方面项目能否顺利进行，是否存在潜在的风险，这些风险的影响程度和降低这些风险的措施，并给出一个合理可行的解决方案。根据可行性分析的结果还可以评估出系统初步的开发费用。

#### 用户需求和系统需求

| 项目 | 用户需求 | 系统需求 |
|------|----------|----------|
| 完善程度 | 一般 | 完善和细化 |
| 阅读对象 | 委托方或客户 | 开发者 |
| 相互关系 | 得到委托方确认 | 用户需求的开始 |

#### 系统涉众

| 类型 | 说明 |
|------|------|
| 最终用户 | 他们是系统的实际使用者，对目标系统有直接的接触和评价 |
| 投资者 | 主要关心的是目标系统的总成本、建设周期及未来的收益等高层目标 |
| 业务提出者 | 使现有的业务能够更加规范和高效，提升业务质量 |
| 业务管理者 | 负责业务计划、生产、监督等环节的实际实施和控制 |
| 业务执行者 | 实际的操作人员，是频繁与系统直接交互的人员 |
| 第三方 | 与业务关联的，但并非业务方的其他人或事 |
| 开发方 | 合同乙方的利益代表，他们关心的是这个项目是否有经济利益，是否能积累核心竞争力，是否能树立品牌，是否能开拓市场 |
| 法律法规 | 既指国家和地方法律法规，又指行业规范和标准 |

#### 系统目标

| 项目 | 内容 |
|------|------|
| 目标 | 设置该目标可以满足的期望 |
| 对涉众的影响 | 对涉众及其影响 |
| 边界条件 | 附加条件或约束 |
| 依赖 | 是否依赖其他目标，与其他目标关系如何，是相辅相成还是此消彼长 |
| 其他 | 其他需要说明的内容 |

dd
